<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Component</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/themes/light.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@recogito/annotorious-openseadragon@2.7.14/dist/annotorious.min.css">

  <style>
    *, *::before, *::after { box-sizing: border-box; }
    @keyframes fadeInOpacity { 0% { opacity: 0; } 100% { opacity: 1; } }
    
    /* ------------------------------------------------------------------
      Global reset so the iframe box behaves predictably
    ------------------------------------------------------------------ */
    html, body {
      margin: 0;
      height: 100%;               /* let the flexbox fill the iframe */
      box-sizing: border-box;
      font-family: system-ui, sans-serif;
    }

    /* ------------------------------------------------------------------
      Layout: figure stretches to full iframe height, image flexes,
      caption is a fixed-height band (16 px text, 8 px padding each side)
    ------------------------------------------------------------------ */
    figure {
      height: 100%;
      margin: 0;
      display: flex;
      flex-direction: column;
    }

    figure img {
      width: 100%;
      height: auto;               /* keeps natural aspect */
      flex: 1 0 0;                /* consume whatever height is left */
      /* object-fit: contain;  */      /* never crop; add 'cover' if you prefer */
    }

    /* ---- caption ------------------------------------------------------- */
    figcaption {
      font-size: 16px;            /* fixed across all iframes */
      line-height: 1.2;
      padding: 8px 0;             /* 8 px top + bottom (fixed) */
      text-align: left;          /* left-align text */
      display: flex;
      align-items: center;
      /* optional styling niceties */
      background: #fff;           /* keeps text readable over dark images */
    }

    /* ---- any inline SVG icons in the caption --------------------------- */
    figcaption svg {
      width: 1em;                 /* 1 × font-size → scales with 16 px text */
      height: 1em;
      margin-inline: .3em;
      flex: none;                 /* don’t let flexbox shrink it */
      fill: currentColor;         /* inherit text colour automatically */
      cursor: pointer;
    }
    main { height: 100%; display: flex; flex-direction: column; width: 100%; visibility: hidden; } 
    .content { display: inline-block; overflow: hidden; position: relative; height: 100%; }
    .content img { display: block; width: 100%; height: 100%; object-fit: cover; }
    /*
    body { height:100dvh; margin: 0; padding: 0; font-family: 'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif; animation: fadeInOpacity ease 1s; background-color: white; }    
    figure { display: grid; grid-template-rows: 1fr auto; height: 100%; margin: 0; }
    figcaption { display: inline-flex; align-items: center; gap: 0.4em; line-height: 1.2; }
    figcaption svg { width: 1em; height: 1em; flex: none; fill: currentColor; cursor: pointer; }
    .content img { display: block; width: 100%; height: 100%; object-fit: contain; }
    .content .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 1; }
    */
    #osd { display:none; height: 100%; width:100%; position: relative; opacity: 0; animation: fadeInOpacity ease 1s; }
    .manifestButton { width: 1.3em; height: 1.3em; cursor: pointer; }
    .clamp { display: -webkit-box; -webkit-line-clamp: 1; -webkit-box-orient: vertical; overflow: hidden; }
    sl-drawer::part(base) { box-shadow: rgba(0, 0, 0, 0.24) 0px 3px 8px; }
    sl-drawer::part(body) { padding: 0; margin: 3px; }
    sl-drawer::part(footer) { padding: 0.5em; border-top: 1px solid #ccc; }
    sl-tab::part(base) { padding: 0.5em 1em; }
    sl-tab-panel::part(base) { padding: 0.5em; }
    sl-tab-panel[aria-hidden=true] { display: none !important; }
    .expandToggle { margin-left: auto; flex-shrink: 0; }
    pre { white-space: pre-wrap; word-wrap: break-word; }
    .wrap { overflow-wrap: break-word; word-wrap: break-word; -ms-word-break: break-all; word-break: break-all; word-break: break-word; }
    .manifest > * { margin: 0.3em; display: none; font-size: 90%;}
    .manifest > div:not(:empty) { display: block; }
    .manifest .label { font-size: 1em; font-weight: bold; }
    .manifest .rights, .manifest .required  { display: flex !important; align-items: center; gap: 1em;}
    .page-info { position: absolute; top: 32px; left: 0; width: 60px; z-index: 1000; background-color: rgba(255, 255, 255, 0.5); padding: 5px; border-radius: 5px; display: flex; flex-direction: column; align-items: center; gap: 3px; opacity: 0; transition: all 0.5s ease-out; }
    .page-info:hover { opacity: 1; }
    .pageid { cursor: copy; }
    .thumbnail { cursor: move; width: 100%; }
    /* img { max-width: 100%; max-height: 100%; object-fit: contain; } */
    /* styles used by bounding box drawing */
    #osd-container { position: relative; width: 100%; height: 100%; user-select: none; }
    #drawing-overlay { position: absolute; top: 0; left: 0; z-index: 10; pointer-events: none; }
    .box { position: absolute; border: 2px solid red; box-sizing: border-box; z-index: 20; }
    .box .handle { position: absolute; width: 8px; height: 8px; background: white; border: 1px solid red; box-sizing: border-box; z-index: 21; }
    .box .handle.nw { top: -4px; left: -4px; cursor: nw-resize; }
    .box .handle.ne { top: -4px; right: -4px; cursor: ne-resize; }
    .box .handle.sw { bottom: -4px; left: -4px; cursor: sw-resize; }
    .box .handle.se { bottom: -4px; right: -4px; cursor: se-resize; }
    .copy-icon { position: absolute; width: 20px; height: 20px; line-height: 20px; text-align: center; background: rgba(255,255,255,0.8); border-radius: 50%; cursor: pointer; z-index: 22; user-select: none;}
  
  </style>
</head>
<body>
  <main>
    
    <figure>
      <div class="content">
        <img>

        <div id="osd-container">
          <div id="osd" style="width:100%; height:100%;">
            <div class="page-info"><div class="pageid"></div><img class="thumbnail" draggable="true" alt="image thumbnail"></div>
          </div>
          <canvas id="drawing-overlay"></canvas>
        </div>

      </div>

      <figcaption>      
        <svg class="drawerToggle" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 512"><path d="M64 360a56 56 0 1 0 0 112 56 56 0 1 0 0-112zm0-160a56 56 0 1 0 0 112 56 56 0 1 0 0-112zM120 96A56 56 0 1 0 8 96a56 56 0 1 0 112 0z"/></svg>
        <div class="title clamp"></div>
        <svg class="expandToggle" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M32 32C14.3 32 0 46.3 0 64l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 32zM64 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 32c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM448 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96z"/></svg>
      </figcaption>

    </figure>

    <sl-drawer contained class="drawer" no-header style="--size: calc(100% - 30px);">
      <sl-tab-group>
        <sl-tab slot="nav" active panel="manifest">Image info</sl-tab>
        <sl-tab-panel active name="manifest">
          <div class="manifest">
            <div class="label"></div>
            <div class="summary"></div>
            <div class="required"></div>
            <div class="rights"></div>
            <div class="source wrap"></div>
            <div class="size"></div>
          </div>
        </sl-tab-panel>
      </sl-tab-group>
      <sl-button slot="footer" variant="primary" size="small" class="close">Close</sl-button>
    </sl-drawer>  

  </main>

  <script src="https://cdn.jsdelivr.net/npm/openseadragon@5.0.0/build/openseadragon/openseadragon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/js-md5@0.8.3/src/md5.min.js"></script>

  <script type="module">

    import { marked } from "https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js";
    import 'https://cdn.jsdelivr.net/npm/marked-footnote/dist/index.umd.min.js'

    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/badge/badge.js';
    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/button/button.js';
    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/copy-button/copy-button.js';
    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/drawer/drawer.js';
    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/tab/tab.js';
    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/tab-group/tab-group.js';
    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/tab-panel/tab-panel.js';

    // let iiifServiceUrl = 'http://localhost:8088';
    let iiifServiceUrl = 'https://iiif.mdpress.io';
    let imageServiceUrl = 'https://d1co2zgwaj21sl.cloudfront.net/image';

    const main = document.querySelector('main')
    const figure = main.querySelector('figure')
    const img = figure.querySelector('img')
    const osd = figure.querySelector('#osd')

    const figcaption = figure.querySelector('figcaption')
    const drawerToggle = figcaption.querySelector('.drawerToggle')

    const captionText = figcaption.querySelector('.title')

    const drawer = document.querySelector('.drawer')
    const title = drawer.querySelector('#title')
    const source = drawer.querySelector('#source')
    const embedCode = drawer.querySelector('#embed-code')

    const md2Html = (md) => marked.parse(md).slice(3, -5) // convert markdown to HTML

    let viewer
    let iiifManifest
    
    const props = {
      ...{ // default properties
        alt: null,    // Alt text string
        base: null,     // base URL for relative links
        caption: null,  // caption text
        cover: false,
        format: null,
        ghbase: null,
        iiif: false,
        language: 'en',
        manifest: null,
        nocaption: false,
        options: null,  // IIIF region, size, rotation, quality, format
        quality: null,
        region: null,   // initial region to zoom to
        rotation: 0,
        seq: 1,         // sequence number of image in multi-image manifest, default is 1 for first image
        size: null,     // size of image to display
        src: null
      },
      ...Object.fromEntries(
        (location.href.split('?')[1] || '')
        .split('&')
        .map(p => p.split('='))
        .map(([key, value]) => [key, value ? decodeURIComponent(value.replace(/\+/g, ' ')) : true])
      )
    };
    ['rotation', 'seq'].forEach(prop => props[prop] = parseInt(props[prop]) || props[prop]) // convert to number if possible
    console.log(props)

    let id;
    let imageAspect;
    const docReady = (fn) => { if (document.readyState === 'complete' || document.readyState === 'interactive') setTimeout(fn, 1); else document.addEventListener('DOMContentLoaded', fn) }
    docReady(function() {
      
      window.parent.postMessage({ type: 'getID' }, '*');
      window.addEventListener('message', (event) => {
        let eventData = JSON.parse(event.data)
        let action = eventData.action?.toLowerCase()
        let text = eventData.text
        let args = eventData.args
        if (eventData.event === 'id') {
          id = eventData.id;
        } else if (action === 'zoomto') {
          zoomto(args[0], text)
        } else if (action === 'gotopage') {
          gotopage(parseInt(args[0]))
        } else if (action === 'gotopageid') {
          gotopageid(event.data.args[0])
       } else if (action === 'getimageurl') {
          event.source.postMessage({ action: 'imageurl', url: img.src }, '*')
        }
      });
      main.style.visibility = 'visible'
    })

    const pageInfo = document.querySelector('.page-info')
    const pageIdEl = pageInfo.querySelector('.pageid')
    pageIdEl.onclick = () => navigator.clipboard.writeText(pageIdEl.textContent)
    const thumbnailEl = pageInfo.querySelector('.thumbnail')
    
    thumbnailEl.addEventListener('dragstart', (e) => {
      let imgURL = staticImageUrl()
      e.dataTransfer.setData('text/plain', imgURL)
      e.dataTransfer.setData('text/uri-list', imgURL)
    })
    thumbnailEl.addEventListener('click', (e) => navigator.clipboard.writeText(currentImageUrl()))
    const setPageInfo = (pageId) => {
      pageIdEl.innerHTML = props.seq
      let thumb = staticImageUrl(200)
      // console.log('setPageInfo', thumb)
      // thumbnailEl.src = thumb
    }

    const setTileSource = (canvas) => {
      const page = findItem({type:'AnnotationPage'}, canvas)
      const itemInfo = findItem({type:'Annotation', motivation:'painting'}, page).body
      const tileSource = itemInfo.service
      ? `${(itemInfo.service[0].id || itemInfo.service[0]['@id'])}/info.json`
      : { url: itemInfo.id, type: 'image', buildPyramid: true }
      viewer.open(tileSource)
    }

    const gotopage = (pageNum) => {
      setTileSource(findItems({type:'Canvas'}, iiifManifest)[pageNum-1])
    }

    const gotopageid = (pageId) => {
      setTileSource(findItems({type:'Canvas'}, iiifManifest)
        .find(c => (c.label[props.language] || c.label.none || Object.values(c.label))?.[0] === pageId))
    }

    const toggleDrawerOpen = () => drawer.open = !drawer.open

    const drawerButton = figcaption.querySelector('.drawerToggle')
    drawerButton?.addEventListener('click', e => toggleDrawerOpen())
  
    const expandToggle = figcaption.querySelector('.expandToggle')
    if (props['in-dialog'] && expandToggle) expandToggle.style.display = 'none'
    else {
      expandToggle?.addEventListener('click', e => {
        window.parent.postMessage({ 
          type: 'showDialog', 
          props: {
            kwargs: {
              ...Object.fromEntries(Object.entries(props).filter(([_, value]) => value !== null && value !== false)),
              ...{
                aspect: imageAspect,
                tag: 'image',
                iiif: true,
                cover: true
              }
            }
          }
        }, '*');
      })
    } 

    document.querySelector('.drawer sl-button.close').addEventListener('click', e => toggleDrawerOpen())

    // recursive helper for finding items in a IIIF manifest
    const findItems = (toMatch, current, found) => {
      found = found || []
      if (current?.items) {
        for (let i = 0; i < current.items.length; i++ ) {
          let item = current.items[i]
          let isMatch = !Object.entries(toMatch).find(([attr, val]) => item[attr] && item[attr] !== val)
          if (isMatch) found.push(item)
          else findItems(toMatch, item, found)
        }
      }
      return found
    }

    // find an item in a IIIF manifest
    const findItem = (toMatch, current, seq) => {
      seq = seq || 1
      const found = findItems(toMatch, current)
      return found.length >= seq ? found[seq-1] : null
    }

    const staticImageUrl = (width, crop) => {
      let itemInfo = iiifManifest && findItem({type:'Annotation', motivation:'painting'}, iiifManifest, props.seq).body
      if (!itemInfo) return ''
      if (!imageAspect) imageAspect = itemInfo.width/itemInfo.height
      let url
      let [region, size, rotation, rest] = props.options?.split('/') || []
      let [quality, format] = rest?.split('.') || []
      region = crop || props.region || region || 'full'
      // console.log(`crop=${crop} props.region=${props.region} region=${region}`)
      size = width
        ? width === 'max'
          ? 'max'
          : `${width},`
        : props.size
          ? props.size
          : `${main.clientWidth},`
      rotation = parseInt(props.rotation || rotation || 0)
      quality = props.quality || quality || 'default'
      format = props.format || format || 'jpg'
      url =`${itemInfo.service[0].id || itemInfo.service[0]['@id']}/${region}/${size}/${rotation}/${quality}.${format}`
      return url
    }

    const mwImage = (mwImg, width) => {
      width = width | 0
      // Converts Wikimedia commons image URL to a thumbnail link
      mwImg = (Array.isArray(mwImg) ? mwImg[0] : mwImg).replace(/Special:FilePath\//, 'File:').split('File:').pop()
      mwImg = decodeURIComponent(mwImg).replace(/ /g,'_')
      const _md5 = md5(mwImg)
      const extension = mwImg.split('.').pop()
      let url = `https://upload.wikimedia.org/wikipedia/commons${width ? '/thumb' : ''}`
      url += `/${_md5.slice(0,1)}/${_md5.slice(0,2)}/${mwImg}`
      if (width > 0 || ['svg', 'tif'].includes(extension)) {
        url += `/${width || 1000}px-${mwImg}`
        if (extension === 'svg') url += '.png'
        else if (extension === 'tif' || extension === 'tiff') url += '.jpg'
      }
      return url
    }

    const wdImage = async (qid) => {
      const query = `SELECT ?image WHERE { wd:${qid} wdt:P18 ?image. } LIMIT 1 `;    
      const url = 'https://query.wikidata.org/sparql?query=' + encodeURIComponent(query);
      const headers = { 'Accept': 'application/sparql-results+json' };
      const response = await fetch(url, { headers });
      if (!response.ok) { throw new Error(`SPARQL query failed: ${response.status}`); }
      const json = await response.json();
      const image = json?.results?.bindings?.[0]?.image?.value;
      return image?.replace(/Special:FilePath\//, 'File:').split('File:').pop() || null;
    }

    const initViewer = async () => {
      if (viewer) return viewer
      if (iiifManifest) {
        img.style.display = 'none'
        osd.style.display = 'block'
        osd.style.opacity = 1
        return initOsd(getTileSources())
      } else {
        return loadManifest(props.manifest)
          .then(manifest => {
            img.style.display = 'none'
            osd.style.display = 'block'
            osd.style.opacity = 1
            return initOsd(getTileSources())
          })
      }
    }

    const setCaption = (text) => {
      text = text
        ? text
        : props.caption
          ? props.caption
          : iiifManifest
            ? (iiifManifest?.label?.en || iiifManifest?.label?.none || Object.values(iiifManifest.label)).join(' ')
            : decodeURI(img.src.split('/').pop().replace(/^\d+px-/,'').replace(/\.(jpg|jpeg|png|gif)$/,'').replace(/[-_]+/g,' '))
      if (props.nocaption === true) {
        figcaption.style.display = 'none'
      } else {
        captionText.innerHTML = md2Html(text)    
        // figcaption.style.display = 'flex'
      }
      img.setAttribute('atl', props.alt || text)
    }

    const loadImage = (url) => {
      img.onload = (e) => {
        imageAspect = img.naturalWidth/img.naturalHeight
        if (!props.aspect) {
          let width = props.width || main.clientWidth
          let aspect = width/(width / imageAspect + figcaption.clientHeight)
          window.parent.postMessage({ type: 'setAspect', aspect }, '*')
        }
      }
      img.src = url
      let altText = props.caption
        ? props.caption
        : iiifManifest
          ? (iiifManifest?.label?.en || iiifManifest?.label?.none || Object.values(iiifManifest.label)).join(' ')
          : decodeURI(img.src.split('/').pop().replace(/^\d+px-/,'').replace(/\.(jpg|jpeg|png|gif)$/,'').replace(/[-_]+/g,' '))
      img.setAttribute('alt', altText)
      // img.style.objectFit = props.cover === true ? 'cover' : 'contain'
      img.addEventListener('click', () => {
        window.parent.postMessage({ 
          type: 'showDialog', 
          props: {
            kwargs: {
              ...Object.fromEntries(Object.entries(props).filter(([_, value]) => value !== null && value !== false)),
              ...{
                aspect: imageAspect,
                tag: 'image',
                iiif: true,
                cover: true
              }
            }
          }
        }, '*');
      })
    }

    const loadManifest = (manifestUrl) => {
      return fetch(manifestUrl).then(resp => resp.json())
      .then( async manifest => {
        const contexts = Array.isArray(manifest['@context']) ? manifest['@context'] : [manifest['@context']]
        const isV3Manifest = contexts.find(ctx => ctx.indexOf('shared-canvas.org') > 0 || parseFloat(ctx.split('/').slice(-2,-1).pop()) < 3) ? false : true
        return isV3Manifest 
          ? manifest 
          : await fetch(`${iiifServiceUrl}/prezi2to3/`, { method: 'POST', body: JSON.stringify(manifest) }).then(resp => resp.json())
      })
      .then(manifest => {
        iiifManifest = manifest
        setCaption()
        updateManifestPanel()
        if (!props.src || props.region) loadImage(`${imageServiceUrl}/${staticImageUrl()}`)
      })
      return iiifManifest
    }

    const getTileSources = () => {
      const canvases = findItems({type:'Canvas'}, iiifManifest)
      const tiledSources = canvases.map(canvas => {
        const page = findItem({type:'AnnotationPage'}, canvas)
        const itemInfo = findItem({type:'Annotation', motivation:'painting'}, page).body
        return itemInfo.service
          ? `${(itemInfo.service[0].id || itemInfo.service[0]['@id'])}/info.json`
          : { url: itemInfo.id, type: 'image', buildPyramid: true }
      })
      return tiledSources
    }

    if (props.src) {
      let imgUrl
      if (props.src.indexOf('http') === 0) {
        imgUrl = `${imageServiceUrl}/${encodeURIComponent(props.src)}`
        props.manifest = `${iiifServiceUrl}/${encodeURIComponent(props.src)}/manifest.json`
      } else if (props.src.indexOf('wc:') === 0 || props.src.indexOf('wikimedia.org') > -1 || props.src.indexOf('wikipedia.org') > -1 && props.src.indexOf('/media/File:') > -1) {
        let mwFile = props.src.replace(/^wc:/,'').replace(/Special:FilePath\//, 'File:').split('File:').pop()
        imgUrl = `${imageServiceUrl}/wc:${mwFile}`
        props.manifest = `${iiifServiceUrl}/wc:${mwFile}/manifest.json`
      } else if (props.src.indexOf('gh:') === 0) {
        imgUrl = `${imageServiceUrl}/${props.src}`
        props.manifest = `${iiifServiceUrl}/${props.src}/manifest.json`
      } else if (props.src.indexOf('wd:') === 0 || /^Q[0-9]+$/.test(props.src)) {
        const qid = props.src.replace(/^wd:/, '')
        wdImage(qid).then(mwFile => {
          props.manifest = `${iiifServiceUrl}/wc:${mwFile}/manifest.json`
          setCaption()
        })
      } else {
        if (props.src[0] === '/') {
          let [owner, repo, branch, ...rest] = props.ghbase.split('/')
          imgUrl = `${imageServiceUrl}/gh:${owner}/${repo}/${branch}${props.src}`
          props.manifest = `${iiifServiceUrl}/gh:${owner}/${repo}/${branch}${props.src}/manifest.json`
        } else {
          imgUrl = `${imageServiceUrl}/gh:${props.ghbase}/${props.src}`
          props.manifest = `${iiifServiceUrl}/gh:${props.ghbase}/${props.src}/manifest.json`
        }
      }
      if (!props.iiif && !props.region) loadImage(imgUrl)
      loadManifest(props.manifest).then(_ => { if (props.iiif) initViewer() })
    
    } else if (props.manifest) {
      if (!props.manifest.startsWith('http')) {
        if (/^[a-z]+:/.test(props.manifest)) props.manifest = `${iiifServiceUrl}/${props.manifest}/manifest.json`
        else {
          if (props.manifest[0] === '/') {
            let [owner, repo, branch, ...rest] = props.ghbase.split('/')
            props.manifest = `${iiifServiceUrl}/gh:${owner}/${repo}/${branch}${props.manifest}/manifest.json`
          } else {
            props.manifest = `${iiifServiceUrl}/gh:${props.ghbase}/${props.manifest}/manifest.json`
          }
        }
      }
      loadManifest(props.manifest).then(_ => { if (props.iiif) initViewer() })
    }

    setCaption()

    const parseManifest = () =>{

      const valueOf = (langObj, language) => {
        language = language || props.language
        return typeof langObj === 'object' && !Array.isArray(langObj)
          ? langObj[language] || langObj.none || langObj[Object.keys(langObj).sort()[0]]
          : langObj
      }

      const licenseBadge = (rights) => {
        let config = {
          cc: {
            badgeWidth: 88,
            badgeHeight: 31,
            badgeTemplate: 'https://licensebuttons.net/l/${this.rightsCode}${this.rightsCode === "publicdomain" ? "" : "/"+this.version}/${this.badgeWidth}x${this.badgeHeight}.png'
          },
          rs: {
            badgeTemplate: 'https://rightsstatements.org/files/buttons/${this.rightsCode}.white.svg',
            backgroundColor: '318ac7'
          }
        }
        const fillTemplate = (templateString, templateVars) => new Function("return `"+templateString +"`;").call(templateVars)
  
        let badgeHtml = ''
        let [rightsType, _, rightsCode, version] = rights.split('/').slice(2)
        if (rightsType === 'creativecommons.org') {
          rightsCode = rightsCode === 'zero' ? 'publicdomain' : rightsCode
          // rightsCode = rightsCode === 'zero' ? 'publicdomain' : `CC ${rightsCode}`
          badgeHtml = `<img src="${fillTemplate(config.cc.badgeTemplate, {...config.cc, ...{rightsCode, version}})}"/>` 
        } else if (rightsType === 'rightsstatements.org') {
          badgeHtml = `<div style="display:inline-block;height:25px;padding:3px;background-color:#${config.rs.backgroundColor};"><img style="height:100%;" src="${fillTemplate(config.rs.badgeTemplate, {...config.rs, ...{rightsCode}})}"/></div>`
        }
        return badgeHtml
      }  

      let parsed = {}
  
      parsed.id = valueOf(iiifManifest.id)
      parsed.label = valueOf(iiifManifest.label)
  
      if (iiifManifest.summary) parsed.summary = valueOf(iiifManifest.summary)
      if (iiifManifest.rights) {
        let [rightsType, _, rightsCode, version] = iiifManifest.rights.split('/').slice(2)
        if (rightsType === 'creativecommons.org') rightsCode = rightsCode === 'zero' ? 'publicdomain' : `CC ${rightsCode}`
        parsed.rights = {
          code: `${rightsCode} ${version}`.toUpperCase(),
          url: iiifManifest.rights,
          badge: licenseBadge(iiifManifest.rights)
        }
      }
      if (iiifManifest.thumbnail) parsed.thumbnail = iiifManifest.thumbnail[0].id || iiifManifest.thumbnail
      
      if (iiifManifest.metadata) {
        parsed.metadata = iiifManifest.metadata.map((item) => ({label: valueOf(item.label)[0], value: valueOf(item.value)}))
        let sourceUrl = parsed.metadata.find((item) => item.label == 'source_url' || item.label == 'source')
        parsed.sourceUrl = sourceUrl ? sourceUrl.value[0] : null
  
        let depicts = parsed.metadata.find((md) => md.label === 'depicts')
        if (depicts) parsed.depicts = depicts.value
      }
  
      if (iiifManifest.provider) {
        parsed.provider = iiifManifest.provider.map((provider) => {
          let entry = {label: valueOf(provider.label), href:provider.id}
          if (provider.logo) entry.logo = {src:provider.logo[0].id}
          return entry
        })
      }
  
      if (iiifManifest.logo) {
        parsed.logo = iiifManifest.logo.map((item) => {
          let logoObj = { src: typeof item === 'object' ? item.id || item['@id'] : item }
          if (typeof item === 'object') {
            if (item.width) logoObj.width = item.width
            if (item.height) logoObj.height = item.height
          }
          return logoObj
        })
      }
  
      parsed.imageData = findItem({type:'Annotation', motivation:'painting'}, iiifManifest, props.seq)?.body
      parsed.service = parsed.imageData.service && `${(parsed.imageData.service[0].id || parsed.imageData.service[0]['@id'])
        .replace(/\/info\.json$/,'')}/info.json`
        if (iiifManifest.requiredStatement) {
          let rs = iiifManifest.requiredStatement
          // parsed.requiredStatement = {label: valueOf(rs.label)[0], value: valueOf(rs.value)}
        }
  
      if (iiifManifest.homepage) {
        parsed.homepage = {label: iiifManifest.homepage.label ? valueOf(iiifManifest.homepage.label) : iiifManifest.homepage.id, href: iiifManifest.homepage.id}
      }
  
      if (iiifManifest.seeAlso) {
        parsed.seeAlso = iiifManifest.seeAlso.map((seeAlso) => ({label: seeAlso.label ? valueOf(seeAlso.label) : seeAlso.id, href: seeAlso.id}))
      }
      
      return parsed
    }

    const updateManifestPanel = () => {
      let parsed = parseManifest()      
      if (parsed.label) document.querySelector('.manifest .label').innerHTML = parsed.label.join(' ')
      if (parsed.summary) document.querySelector('.manifest .summary').innerHTML = parsed.summary.join(' ')
      if (parsed.requiredStatement) document.querySelector('.manifest .required').innerHTML = `<span><b>Attribution:</b></span> <span>${parsed.requiredStatement.value.join(' ')}</span>`
      if (parsed.rights) document.querySelector('.manifest .rights').innerHTML = `<span><b>Reuse rights:</b></span><a href="${parsed.rights.url}">${parsed.rights.code}</a>` + (parsed.rights.badge || '')
      if (parsed.sourceUrl) document.querySelector('.manifest .source').innerHTML = `<span><b>Source:</b></span> <a href="${parsed.sourceUrl}">${parsed.sourceUrl}</a>`
      if (parsed.imageData) {
        if (!imageAspect) imageAspect = parsed.imageData.width/parsed.imageData.height
        document.querySelector('.manifest .size').innerHTML = `<span><b>Size:</b></span> ${parsed.imageData.width.toLocaleString()} × ${parsed.imageData.height.toLocaleString()} (${imageAspect.toFixed(2)})`
      } else {
        document.querySelector('.manifest .size').innerHTML = ''
      }
      drawer.querySelectorAll('a').forEach(a => {
        a.addEventListener('click', e => {
          e.stopPropagation()
          e.preventDefault()
          window.parent.postMessage({ type: 'openLink', url: a.href, newtab: true }, '*');
        })
      })

    }

    /**
    * Expand a bounding box to twice its width and height,
    * centering the original box inside the new one.
    *
    * @param {{x:number, y:number, w:number, h:number}} box
    *   The original bounding box.
    * @param {'round'|'floor'|'ceil'} [rounding='round']
    *   How to round the computed coordinates.
    * @returns {{x:number, y:number, w:number, h:number}}
    *   The expanded, centered bounding box.
    */
    function expandBox(box, rounding = 'round') {
      let scale = 1.8;
      // New dimensions
      const newW = box.w * scale;
      const newH = box.h * scale;

      // Center of the original box
      const cx = box.x + box.w / scale;
      const cy = box.y + box.h / scale;

      // Compute top-left of the expanded box so it's centered on (cx,cy)
      let x = cx - newW / scale;
      let y = cy - newH / scale;

      // Apply rounding
      if (rounding === 'floor') {
        x = Math.floor(x);
        y = Math.floor(y);
      } else if (rounding === 'ceil') {
        x = Math.ceil(x);
        y = Math.ceil(y);
      } else {
        x = Math.round(x);
        y = Math.round(y);
      }

      return { x, y, w: newW, h: newH };
    }
    
    /**
    * Place a padded, semi‐transparent text caption under a box,
    * with fully opaque text.
    *
    * @param {OpenSeadragon.Viewer} viewer
    * @param {{x:number,y:number,w:number,h:number}} box   Image‐pixel bbox
    * @param {string} text                                  Caption text
    * @param {object} [opts]
    * @param {number} [opts.fontSize=16]        Font size in px
    * @param {string} [opts.bgColor='#000']     Background hex color (e.g. '#000', '#ff0000')
    * @param {number} [opts.bgOpacity=0.5]      Background alpha (0–1)
    * @param {string} [opts.textColor='#fff']   Text color
    * @param {number} [opts.paddingEm=0.5]      Padding around text (in em)
    * @returns {HTMLElement}                     The caption element
    */
    function addTextBelowBox(viewer, box, text, opts = {}) {
      // Default options
      const {
        fontSize   = 16,
        bgColor    = '#000',
        bgOpacity  = 0.5,
        textColor  = '#fff',
        paddingEm  = 0.5,
      } = opts;

      // Helper: turn '#rgb' or '#rrggbb' into 'rgba(r,g,b,alpha)'
      function hexToRgba(hex, alpha) {
        let h = hex.replace('#','');
        if (h.length === 3) {
          h = h.split('').map(c => c + c).join('');
        }
        const int = parseInt(h, 16);
        const r = (int >> 16) & 255;
        const g = (int >> 8) & 255;
        const b = int & 255;
        return `rgba(${r},${g},${b},${alpha})`;
      }

      // 1) Create and style the DIV
      const div = document.createElement('div');
      div.textContent = text;
      Object.assign(div.style, {
        position:        'absolute',
        display:         'inline-block',
        fontSize:        fontSize + 'px',
        backgroundColor: hexToRgba(bgColor, bgOpacity),
        color:           textColor,
        padding:         `${paddingEm}em`,
        boxSizing:       'border-box',
        whiteSpace:      'pre-wrap',
        pointerEvents:   'none',
        opacity:         '1'            // ensure text remains fully opaque
      });

      // 2) Compute the bottom-center of the box in image coords
      const imgX = box.x + box.w/2;
      const imgY = box.y + box.h;

      // 3) Convert to viewport coords
      const vp = viewer.viewport.imageToViewportCoordinates(imgX, imgY);

      // 4) Add as a TOP-centered overlay (auto-width)
      viewer.addOverlay({
        element:   div,
        location:  new OpenSeadragon.Point(vp.x, vp.y),
        placement: OpenSeadragon.Placement.TOP
      });

      return div;
    }

    /**
    * Draws a border around an image‐pixel box in an OpenSeadragon viewer.
    *
    * @param {OpenSeadragon.Viewer} viewer
    * @param {{x:number,y:number,w:number,h:number}} box
    *        Box in image‐pixel coords (top-left + width/height).
    * @param {object} [opts]
    * @param {string} [opts.color='red']     Border color (any CSS color).
    * @param {number} [opts.lineWidth=2]     Border thickness in px.
    * @returns {HTMLElement}                 The overlay element (for later removal).
    */
    function drawBoxBorder(viewer, box, opts = {}) {
      const {
        color     = 'red',
        lineWidth = 2,
      } = opts;

      // 1) make a DIV sized to 100% × 100% of its overlay rectangle,
      //    with only a border and transparent fill
      const div = document.createElement('div');
      Object.assign(div.style, {
        position:      'absolute',
        width:         '100%',
        height:        '100%',
        boxSizing:     'border-box',
        border:        `${lineWidth}px solid ${color}`,
        background:    'transparent',
        pointerEvents: 'none',
      });

      // 2) map the box corners to viewport coords
      const vpTL = viewer.viewport.imageToViewportCoordinates(box.x,         box.y);
      const vpTR = viewer.viewport.imageToViewportCoordinates(box.x + box.w, box.y);
      const vpBL = viewer.viewport.imageToViewportCoordinates(box.x,         box.y + box.h);

      const widthVP  = vpTR.x - vpTL.x;
      const heightVP = vpBL.y - vpTL.y;

      // 3) build the overlay rectangle
      const rect = new OpenSeadragon.Rect(
        vpTL.x,
        vpTL.y,
        widthVP,
        heightVP
      );

      // 4) add it to the viewer
      viewer.addOverlay({
        element:  div,
        location: rect
      });

      return div;
    }

    const parseRegionString = (region, center) => {
      const s1 = region.split(':')
      let [x,y,w,h] = s1[s1.length-1].split(',').map(v => parseInt(v))
      const size = viewer.world.getItemAt(0)?.getContentSize()
      if (!size) return
      if (s1.length === 2 && (s1[0] === 'pct' || s1[0] === 'percent')) {
        x = Math.round(size.x * x/100),
        y = Math.round(size.y * y/100),
        w = Math.round(size.x * w/100), 
        h = Math.round(size.y * h/100)
      }
      return center
        ? ({x, y, w, h} = expandBox({x, y, w, h}))
        : ({x, y, w, h})
    }

    let zoomedToRegion = ''
    const zoomto = (regionStr, caption) => {
      initViewer().then(resp => {
        viewer.clearOverlays();
        if (zoomedToRegion === regionStr) {
          viewer.viewport.goHome()
          zoomedToRegion = ''
        } else {
          zoomedToRegion = regionStr
          let region = parseRegionString(regionStr, false)
          let expandedRegion = parseRegionString(regionStr, true)
          setTimeout(() => {
            let rect = viewer.viewport.imageToViewportRectangle(...Object.values(expandedRegion))
            viewer.viewport.fitBounds(rect, false)
            const borderEl = drawBoxBorder(viewer, region, {
              color:     '#FFFF00',
              lineWidth: 2
            });
            addTextBelowBox(viewer, region, caption, {
              fontSize:  '1em',
              bgColor:   "#fff",
              bgOpacity: 0.8,
              textColor: "#000",
              paddingEm: 0.3
            });
          }, 100)
        }
      })
    }

    const boundingBoxHandler = (e) => {
      const container = document.getElementById("osd");
      const overlay   = document.getElementById("drawing-overlay");
      const ctx       = overlay.getContext("2d");
      let isDrawing = false, startX = 0, startY = 0;
  
      // Array of { rect, el, updateOverlay }
      const boxes = [];
  
      function resizeOverlay() {
        overlay.width  = container.clientWidth;
        overlay.height = container.clientHeight;
      }
      window.addEventListener("resize", resizeOverlay);
      resizeOverlay();
  
      function updateAllBoxes() {
        boxes.forEach(b => b.updateOverlay());
      }
  
      viewer.addHandler("viewport-change", updateAllBoxes);
  
      // === NEW BOX DRAWING ===
      container.addEventListener("pointerdown", e => {
        if (!e.shiftKey) return;
        e.preventDefault(); e.stopImmediatePropagation();
        isDrawing = true;
        viewer.setMouseNavEnabled(false);
        overlay.style.pointerEvents = "auto";
        const r = overlay.getBoundingClientRect();
        startX = e.clientX - r.left;
        startY = e.clientY - r.top;
      }, { capture: true });
  
      document.addEventListener("pointermove", e => {
        if (!isDrawing) return;
        const r = overlay.getBoundingClientRect();
        const x = e.clientX - r.left, y = e.clientY - r.top;
        ctx.clearRect(0,0,overlay.width,overlay.height);
        ctx.strokeStyle = "red"; ctx.lineWidth = 2;
        ctx.strokeRect(startX, startY, x - startX, y - startY);
      });
  
      document.addEventListener("pointerup", e => {
        if (!isDrawing) return;
        isDrawing = false;
        viewer.setMouseNavEnabled(true);
        overlay.style.pointerEvents = "none";
        ctx.clearRect(0,0,overlay.width,overlay.height);
  
        const r = overlay.getBoundingClientRect();
        const endX = e.clientX - r.left, endY = e.clientY - r.top;
        const tl = viewer.viewport.pointFromPixel(new OpenSeadragon.Point(startX, startY));
        const br = viewer.viewport.pointFromPixel(new OpenSeadragon.Point(endX, endY));

        const rect = { x: tl.x, y: tl.y, width: br.x - tl.x, height: br.y - tl.y };

        // Create the HTML overlay
        const boxEl = document.createElement("div");
        boxEl.className = "box";
        container.appendChild(boxEl);
  
        // Resize handlers
        ['nw','ne','sw','se'].forEach(pos => {
          const h = document.createElement("div");
          h.className = `handle ${pos}`;
          boxEl.appendChild(h);
        });
  
        // Copy icon
        const icon = document.createElement('div');
        icon.className = 'copy-icon';
        icon.textContent = '📋';
        boxEl.appendChild(icon);
        icon.addEventListener('click', () => {
          if (document.hasFocus()) {
            navigator.clipboard.writeText('Hello world!')
              .catch(err => console.error('Copy failed:', err));
          } else {
            alert('Please click on the window to focus it before copying.');
          }
          const regionPct = `pct:${(rect.x*100).toFixed(2)},${(rect.y*100*imageAspect).toFixed(2)},${(rect.width*100).toFixed(2)},${(rect.height*100*imageAspect).toFixed(2)}`
          navigator.clipboard.writeText(`${id}/zoomto/${regionPct}`);
        });

        // Define updateOverlay function
        function updateOverlay() {
          const tlp = viewer.viewport.pixelFromPoint(new OpenSeadragon.Point(rect.x, rect.y), true);
          const brp = viewer.viewport.pixelFromPoint(new OpenSeadragon.Point(rect.x + rect.width, rect.y + rect.height), true);
          const w = brp.x - tlp.x, h = brp.y - tlp.y;
          boxEl.style.left   = tlp.x + "px";
          boxEl.style.top    = tlp.y + "px";
          boxEl.style.width  = w + "px";
          boxEl.style.height = h + "px";
          // position icon
          icon.style.left = (w - 10) + "px";
          icon.style.top  = (h - 10) + "px";
        }
  
        // Initial positioning
        updateOverlay();
  
        // Add to array
        boxes.push({ rect, el: boxEl, updateOverlay });
  
        // === MOVE & RESIZE INTERACTIONS ===
        let action = null, handlePos = null, startPx = 0, startPy = 0, origRect;
  
        boxEl.addEventListener("pointerdown", e => {
          e.stopPropagation(); e.preventDefault();
          if (e.target.classList.contains("handle")) {
            action = "resize";
            handlePos = ['nw','ne','sw','se'].find(p => e.target.classList.contains(p));
          } else {
            action = "move";
          }
          viewer.setMouseNavEnabled(false);
          startPx = e.clientX; startPy = e.clientY;
          origRect = { ...rect };
        });
  
        document.addEventListener("pointermove", e => {
          if (!action) return;
          const dx = e.clientX - startPx, dy = e.clientY - startPy;
          // get original corners in pixel space
          const tlp = viewer.viewport.pixelFromPoint(new OpenSeadragon.Point(origRect.x, origRect.y), true);
          const brp = viewer.viewport.pixelFromPoint(
            new OpenSeadragon.Point(origRect.x + origRect.width, origRect.y + origRect.height), true
          );
          let leftPx = tlp.x, topPx = tlp.y, rightPx = brp.x, bottomPx = brp.y;
  
          if (action === "move") {
            leftPx += dx; rightPx += dx;
            topPx  += dy; bottomPx += dy;
          } else {
            if (handlePos.includes("n")) topPx    += dy;
            if (handlePos.includes("s")) bottomPx += dy;
            if (handlePos.includes("w")) leftPx   += dx;
            if (handlePos.includes("e")) rightPx  += dx;
          }
  
          // convert back to image coords
          const newTL = viewer.viewport.pointFromPixel(new OpenSeadragon.Point(leftPx, topPx));
          const newBR = viewer.viewport.pointFromPixel(new OpenSeadragon.Point(rightPx, bottomPx));
          rect.x      = newTL.x;
          rect.y      = newTL.y;
          rect.width  = newBR.x - newTL.x;
          rect.height = newBR.y - newTL.y;

          updateOverlay();
        });
  
        document.addEventListener("pointerup", () => {
          if (!action) return;
          action = null;
          viewer.setMouseNavEnabled(true);
        });
      });
  
      // Clear on Escape
      document.addEventListener("keydown", e => {
        if (e.key === "Escape") {
          boxes.forEach(b => container.removeChild(b.el));
          boxes.length = 0;
        }
      });
    }

    const initOsd = async (tileSources) => {
      // create the OpenSeadragon viewer
      viewer = OpenSeadragon({
        id: 'osd',
        prefixUrl: 'https://openseadragon.github.io/openseadragon/images/',
        homeFillsViewer: props.cover,
        tileSources,
        crossOriginPolicy: 'Anonymous',
        sequenceMode: tileSources.length > 1,
        initialPage: props.seq - 1,
        showReferenceStrip: tileSources.length > 1,
        zoomPerClick: 1.25,
        maxZoomPixelRatio: 10,
        gestureSettingsMouse: {
          dragToPan: true,
          scrollToZoom: true,
          clickToZoom: true,
          dblClickToZoom: false,
          dblClickDragToZoom: false,
          pinchToZoom: false,
          zoomToRefPoint: false,
          flickEnabled: false,
          flickMinSpeed: 120,
          flickMomentum: 0.25,
          pinchRotate: false
        },
        gestureSettingsTouch: {
          dragToPan: true,
          scrollToZoom: false,
          clickToZoom: false,
          dblClickToZoom: true,
          dblClickDragToZoom: true,
          pinchToZoom: true,
          zoomToRefPoint: false,
          flickEnabled: false,
          flickMinSpeed: 120,
          flickMomentum: 0.25,
          pinchRotate: false
        }
      })
      setPageInfo()

      // display the region coordinates
      let debounce = null

      viewer.addHandler('page', (e) => { 
        props.seq = e.page+1
        setPageInfo()
      })

      viewer.world.addHandler('add-item', (e) => {
        if (props.rotation) e.item.setRotation(parseInt(props.rotation), true)
        if (props.region) {
          let rect = viewer.viewport.imageToViewportRectangle(...Object.values(parseRegionString(props.region)))
          setTimeout(() => viewer.viewport.fitBounds(rect, true), 0)
        } else{
          setTimeout(() => { viewer.viewport.goHome(true) }, 100)
        }
      })

      viewer.addHandler("open", () => boundingBoxHandler())
      return new Promise((resolve, reject) => {
        
        // Listen for the 'open' event which fires when the initial image is loaded
        viewer.addOnceHandler('open', () => resolve(viewer))
        
        // Listen for errors
        viewer.addOnceHandler('open-failed', (event) => reject(new Error('Failed to load image: ' + event.message)))

      })

    }

  </script>
</body>
</html>