<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/themes/light.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@recogito/annotorious-openseadragon@2.7.14/dist/annotorious.min.css">

  <style>
    *, *::before, *::after { box-sizing: border-box; }
    @keyframes fadeInOpacity { 0% { opacity: 0; } 100% { opacity: 1; } }
    body { height:100dvh; margin: 0; padding: 0; font-family: 'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif; animation: fadeInOpacity ease 1s; background-color: white; }    
    main { height: 100%; display: flex; flex-direction: column; width: 100%; visibility: hidden; } 
    figure { display: grid; grid-template-rows: 1fr auto; height: 100%; margin: 0; }
    .content { display: inline-block; justify-content: center; align-items: center; overflow: hidden; position: relative; }
    .content img { display: block; width: 100%; height: auto; object-fit: contain; }
    .content .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 1; }

    figcaption { padding: 10px; font-size: 0.9rem; background-color: #f9f9f9; display: flex; align-items: center; gap: 0.5em; }
    svg { width: 1.3em; height: 1.3em; }

    #osd { display:none; height: 100%; width:100%; position: relative; opacity: 0; animation: fadeInOpacity ease 1s; }
    .a9s-annotationlayer { visibility: hidden; }
    .r6o-widget.comment { line-height: 1.5; }
    svg.a9s-annotationlayer .a9s-selection .a9s-inner, svg.a9s-annotationlayer .a9s-annotation .a9s-inner  { stroke-width: 3; stroke: rgba(255,255,0,1.0); }
    .a9s-selection-mask { stroke: none; fill: rgba(0,0,0,0.4); pointer-events: none; }
    .captionBar { display: flex; align-items: center; gap: 0.2em; padding: 0.3em 0.5em; min-height: 2em; background-color: inherit; } 
    .annos { margin-left: auto; display: flex; position: relative; cursor: pointer; }
    .manifestButton { width: 1.3em; height: 1.3em; cursor: pointer; }
    #annosIcon, #annosEditIcon { display: none; }
    .annos svg { width: 1.3em; height: 1.3em; fill: #777; margin-right: 10px; }
    #annosIcon { cursor: pointer; }
    #annos ul { list-style-type: none; padding: 0; margin: 0; }
    #annos ul li { display: flex; align-items: center; gap: 0.5em; padding: 0.2em 0; }
    .annos sl-badge { position: absolute; top: 0; left: 16px; }
    .clamp { display: -webkit-box; -webkit-line-clamp: 1; -webkit-box-orient: vertical; overflow: hidden; }
    /* sl-drawer::part(base) { height: calc(100% - 32px); } */
    sl-drawer::part(base) { box-shadow: rgba(0, 0, 0, 0.24) 0px 3px 8px; }
    sl-drawer::part(body) { padding: 0; margin: 3px; }
    sl-drawer::part(footer) { padding: 0.5em; border-top: 1px solid #ccc; }
    sl-tab::part(base) { padding: 0.5em 1em; }
    sl-tab-panel::part(base) { padding: 0.5em; }
    sl-tab-panel[aria-hidden=true] { display: none !important; }
    .drawer-toggle { width: 1.3em; height: 1.3em; cursor: pointer; }
    pre { white-space: pre-wrap; word-wrap: break-word; }
    .wrap { overflow-wrap: break-word; word-wrap: break-word; -ms-word-break: break-all; word-break: break-all; word-break: break-word; }
    .coords { font-size: .8em; opacity: 0; position: absolute; top: 0; right: 0; background-color: white; border: 1px solid #ccc; padding: 0.5em; z-index: 10; transition: all 0.5s ease-out; }
    .coords:hover { opacity: 1; cursor: copy; }
    .manifest > * { margin: 0.3em; display: none; font-size: 90%;}
    .manifest > div:not(:empty) { display: block; }
    .manifest .label { font-size: 1em; font-weight: bold; }
    .manifest .rights, .manifest .required  { display: flex !important; align-items: center; gap: 1em;}
    .page-info { position: absolute; top: 32px; left: 0; width: 60px; z-index: 1000; background-color: rgba(255, 255, 255, 0.5); padding: 5px; border-radius: 5px; display: flex; flex-direction: column; align-items: center; gap: 3px; opacity: 0; transition: all 0.5s ease-out; }
    .page-info:hover { opacity: 1; }
    .pageid { cursor: copy; }
    .thumbnail { cursor: move; width: 100%; }
    img { max-width: 100%; max-height: 100%; object-fit: contain; }
    #annos, sl-tab-panel[name="annotations"] { display: flex; flex-direction: column; }
    #annos > *, sl-tab-panel[name="annotations"] > * { margin-bottom: 0.5em; }
    ul.annosList li img { height: 50px; width: auto; }

    /* styles used by bounding box drawing */
    #osd-container { position: relative; width: 100%; height: 100%; user-select: none; }
    #drawing-overlay { position: absolute; top: 0; left: 0; z-index: 10; pointer-events: none; }
    .box { position: absolute; border: 2px solid red; box-sizing: border-box; z-index: 20; }
    .box .handle { position: absolute; width: 8px; height: 8px; background: white; border: 1px solid red; box-sizing: border-box; z-index: 21; }
    .box .handle.nw { top: -4px; left: -4px; cursor: nw-resize; }
    .box .handle.ne { top: -4px; right: -4px; cursor: ne-resize; }
    .box .handle.sw { bottom: -4px; left: -4px; cursor: sw-resize; }
    .box .handle.se { bottom: -4px; right: -4px; cursor: se-resize; }
    .copy-icon { position: absolute; width: 20px; height: 20px; line-height: 20px; text-align: center; background: rgba(255,255,255,0.8); border-radius: 50%; cursor: pointer; z-index: 22; user-select: none;}
  
  </style>
</head>
<body>
  <main style="aspect-ratio:1;">
    
    <figure>
      <div class="content">
        <img>

        <div id="osd-container">
          <div id="osd" style="width:100%; height:100%;">
            <div class="page-info"><div class="pageid"></div><img class="thumbnail" draggable="true"></div>
            <div class="coords">region</div>
          </div>
          <canvas id="drawing-overlay"></canvas>
        </div>

      </div>

      <figcaption>      
        <svg class="drawer-toggle" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 512"><path d="M64 360a56 56 0 1 0 0 112 56 56 0 1 0 0-112zm0-160a56 56 0 1 0 0 112 56 56 0 1 0 0-112zM120 96A56 56 0 1 0 8 96a56 56 0 1 0 112 0z"/></svg>
        <div class="title clamp"></div>
        <div class="annos">
          <!-- edit icon -->
          <svg xmlns="http://www.w3.org/2000/svg" id="annosEditIcon" viewBox="0 0 512 512"><path d="M441 58.9L453.1 71c9.4 9.4 9.4 24.6 0 33.9L424 134.1 377.9 88 407 58.9c9.4-9.4 24.6-9.4 33.9 0zM209.8 256.2L344 121.9 390.1 168 255.8 302.2c-2.9 2.9-6.5 5-10.4 6.1l-58.5 16.7 16.7-58.5c1.1-3.9 3.2-7.5 6.1-10.4zM373.1 25L175.8 222.2c-8.7 8.7-15 19.4-18.3 31.1l-28.6 100c-2.4 8.4-.1 17.4 6.1 23.6s15.2 8.5 23.6 6.1l100-28.6c11.8-3.4 22.5-9.7 31.1-18.3L487 138.9c28.1-28.1 28.1-73.7 0-101.8L474.9 25C446.8-3.1 401.2-3.1 373.1 25zM88 64C39.4 64 0 103.4 0 152L0 424c0 48.6 39.4 88 88 88l272 0c48.6 0 88-39.4 88-88l0-112c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 112c0 22.1-17.9 40-40 40L88 464c-22.1 0-40-17.9-40-40l0-272c0-22.1 17.9-40 40-40l112 0c13.3 0 24-10.7 24-24s-10.7-24-24-24L88 64z"/></svg>
          <!-- anno icon -->
          <div id="annosIcon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M160 368c26.5 0 48 21.5 48 48v16l72.5-54.4c8.3-6.2 18.4-9.6 28.8-9.6H448c8.8 0 16-7.2 16-16V64c0-8.8-7.2-16-16-16H64c-8.8 0-16 7.2-16 16V352c0 8.8 7.2 16 16 16h96zm48 124l-.2 .2-5.1 3.8-17.1 12.8c-4.8 3.6-11.3 4.2-16.8 1.5s-8.8-8.2-8.8-14.3V474.7v-6.4V468v-4V416H112 64c-35.3 0-64-28.7-64-64V64C0 28.7 28.7 0 64 0H448c35.3 0 64 28.7 64 64V352c0 35.3-28.7 64-64 64H309.3L208 492z"/></svg>
            <sl-badge variant="primary" pill>1</sl-badge>
          </div>
        </div>
      </figcaption>

    </figure>

    <sl-drawer contained class="drawer" no-header style="--size: calc(100% - 30px);">
      <sl-tab-group>
        <sl-tab slot="nav" active panel="manifest">Image info</sl-tab>
        <sl-tab slot="nav" panel="annotations">Annotations</sl-tab>
        <sl-tab-panel active name="manifest">
          <div class="manifest">
            <div class="label"></div>
            <div class="summary"></div>
            <div class="required"></div>
            <div class="rights"></div>
            <div class="source wrap"></div>
            <!--
            <div style="display:flex;align-items: center;gap:0.5em;">
              <span>Page:</span>
              <span id=pageId></span>
              <sl-copy-button></sl-copy-button>
            </div>
            -->
          </div>
        </sl-tab-panel>
        <sl-tab-panel name="annotations">
          <!-- <sl-button id="copyAnnos">Copy annotations to clipboard</sl-button> -->
          <sl-button id="showAnnos" size="small">Enable annotator</sl-button>
          <div id="annos"></div>
        </sl-tab-panel>
      </sl-tab-group>
      <sl-button slot="footer" variant="primary" size="small" class="close">Close</sl-button>
    </sl-drawer>  

    <div class="captionBar" style="display: none;">
      <svg class="drawerToggle" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 512"><path d="M64 360a56 56 0 1 0 0 112 56 56 0 1 0 0-112zm0-160a56 56 0 1 0 0 112 56 56 0 1 0 0-112zM120 96A56 56 0 1 0 8 96a56 56 0 1 0 112 0z"/></svg>
      <div class="label clamp"></div>
      <div class="annos">
        <!-- edit icon -->
        <svg xmlns="http://www.w3.org/2000/svg" id="annosEditIcon" viewBox="0 0 512 512"><path d="M441 58.9L453.1 71c9.4 9.4 9.4 24.6 0 33.9L424 134.1 377.9 88 407 58.9c9.4-9.4 24.6-9.4 33.9 0zM209.8 256.2L344 121.9 390.1 168 255.8 302.2c-2.9 2.9-6.5 5-10.4 6.1l-58.5 16.7 16.7-58.5c1.1-3.9 3.2-7.5 6.1-10.4zM373.1 25L175.8 222.2c-8.7 8.7-15 19.4-18.3 31.1l-28.6 100c-2.4 8.4-.1 17.4 6.1 23.6s15.2 8.5 23.6 6.1l100-28.6c11.8-3.4 22.5-9.7 31.1-18.3L487 138.9c28.1-28.1 28.1-73.7 0-101.8L474.9 25C446.8-3.1 401.2-3.1 373.1 25zM88 64C39.4 64 0 103.4 0 152L0 424c0 48.6 39.4 88 88 88l272 0c48.6 0 88-39.4 88-88l0-112c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 112c0 22.1-17.9 40-40 40L88 464c-22.1 0-40-17.9-40-40l0-272c0-22.1 17.9-40 40-40l112 0c13.3 0 24-10.7 24-24s-10.7-24-24-24L88 64z"/></svg>
        <!-- anno icon -->
        <div id="annosIcon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M160 368c26.5 0 48 21.5 48 48v16l72.5-54.4c8.3-6.2 18.4-9.6 28.8-9.6H448c8.8 0 16-7.2 16-16V64c0-8.8-7.2-16-16-16H64c-8.8 0-16 7.2-16 16V352c0 8.8 7.2 16 16 16h96zm48 124l-.2 .2-5.1 3.8-17.1 12.8c-4.8 3.6-11.3 4.2-16.8 1.5s-8.8-8.2-8.8-14.3V474.7v-6.4V468v-4V416H112 64c-35.3 0-64-28.7-64-64V64C0 28.7 28.7 0 64 0H448c35.3 0 64 28.7 64 64V352c0 35.3-28.7 64-64 64H309.3L208 492z"/></svg>
          <sl-badge variant="primary" pill>1</sl-badge>
        </div>
      </div>
    </div>

  </main>

  <script src="https://cdn.jsdelivr.net/npm/openseadragon@5.0.0/build/openseadragon/openseadragon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@recogito/annotorious-openseadragon@2.7.14/dist/openseadragon-annotorious.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/js-md5@0.8.3/src/md5.min.js"></script>

  <script type="module">

    import { marked } from "https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js";
    import 'https://cdn.jsdelivr.net/npm/marked-footnote/dist/index.umd.min.js'

    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/badge/badge.js';
    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/button/button.js';
    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/copy-button/copy-button.js';
    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/drawer/drawer.js';
    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/tab/tab.js';
    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/tab-group/tab-group.js';
    import 'https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.18.0/cdn/components/tab-panel/tab-panel.js';

    const main = document.querySelector('main')
    const figure = main.querySelector('figure')
    const img = figure.querySelector('img')
    const osd = figure.querySelector('#osd')

    const coords = osd.querySelector('.coords')
    if (coords) coords.onclick = () => navigator.clipboard.writeText(coords.innerHTML)

    const caption = figure.querySelector('figcaption')
    const drawerToggle = caption.querySelector('.drawer-toggle')

    // const caption = document.querySelector('.captionBar')
    const captionText = caption.querySelector('.title')
    const annosEl = caption.querySelector('.annos')
    const annosIcon = annosEl?.querySelector('#annosIcon')
    const annosEditIcon = annosEl?.querySelector('#annosEditIcon')
    const annosBadge = annosEl?.querySelector('sl-badge')

    const drawer = document.querySelector('.drawer')
    const title = drawer.querySelector('#title')
    const source = drawer.querySelector('#source')
    const embedCode = drawer.querySelector('#embed-code')

    const md2Html = (md) => marked.parse(md).slice(3, -5) // convert markdown to HTML

    let viewer
    let annoLayer
    let iiifManifest
    
    const props = {
      ...{ // default properties
        alt: null,    // Alt text string
        annos: null,    // URL to image annotations
        base: null,     // base URL for relative links
        caption: null,  // caption text
        cover: false,
        format: null,
        ghbase: null,
        language: 'en',
        manifest: null,
        nocaption: false,
        options: null,  // IIIF region, size, rotation, quality, format
        quality: null,
        region: null,   // initial region to zoom to
        rotation: 0,
        seq: 1,         // sequence number of image in multi-image manifest, default is 1 for first image
        size: null,     // size of image to display
        showannos: false,
        src: null
      },
      ...Object.fromEntries(
        (location.href.split('?')[1] || '')
        .split('&')
        .map(p => p.split('='))
        .map(([key, value]) => [key, value ? decodeURIComponent(value.replace(/\+/g, ' ')) : true])
      )
    };
    ['rotation', 'seq'].forEach(prop => props[prop] = parseInt(props[prop]) || props[prop]) // convert to number if possible
    // if (props.options || props.size || props.quality || props.format) props.static = true
    console.log(props)

    let imageAspect;

    const setWindowAspect = () => {
      if (!imageAspect) return
      let aspect = main.clientWidth/(main.clientWidth / imageAspect + caption.clientHeight)
      window.parent.postMessage({ type: 'setAspect', aspect }, '*');
    }

    const docReady = (fn) => { if (document.readyState === 'complete' || document.readyState === 'interactive') setTimeout(fn, 1); else document.addEventListener('DOMContentLoaded', fn) }
    docReady(function() {
      
      new ResizeObserver(() => { setWindowAspect() }).observe(document.body)

      window.addEventListener('message', (event) => {
        let eventData = JSON.parse(event.data)
        let action = eventData.action?.toLowerCase()
        let text = eventData.text
        let args = eventData.args
        if (action === 'zoomto') {
          zoomto(args[0], text)
        } else if (action === 'gotopage') {
          gotopage(parseInt(args[0]))
        } else if (action === 'gotopageid') {
          gotopageid(event.data.args[0])
       } else if (action === 'getimageurl') {
          event.source.postMessage({ action: 'imageurl', url: img.src }, '*')
        }
      });
      main.style.visibility = 'visible'
    })

    const pageInfo = document.querySelector('.page-info')
    const pageIdEl = pageInfo.querySelector('.pageid')
    pageIdEl.onclick = () => navigator.clipboard.writeText(pageIdEl.textContent)
    const thumbnailEl = pageInfo.querySelector('.thumbnail')
    
    thumbnailEl.addEventListener('dragstart', (e) => {
      let imgURL = staticImageUrl()
      e.dataTransfer.setData('text/plain', imgURL)
      e.dataTransfer.setData('text/uri-list', imgURL)
    })
    thumbnailEl.addEventListener('click', (e) => navigator.clipboard.writeText(currentImageUrl()))
    const setPageInfo = (pageId) => {
      pageIdEl.innerHTML = props.seq
      let thumb = staticImageUrl(200)
      // console.log('setPageInfo', thumb)
      thumbnailEl.src = thumb
    }

    const setTileSource = (canvas) => {
      const page = findItem({type:'AnnotationPage'}, canvas)
      const itemInfo = findItem({type:'Annotation', motivation:'painting'}, page).body
      const tileSource = itemInfo.service
      ? `${(itemInfo.service[0].id || itemInfo.service[0]['@id'])}/info.json`
      : { url: itemInfo.id, type: 'image', buildPyramid: true }
      viewer.open(tileSource)
    }

    const gotopage = (pageNum) => {
      setTileSource(findItems({type:'Canvas'}, iiifManifest)[pageNum-1])
    }

    const gotopageid = (pageId) => {
      setTileSource(findItems({type:'Canvas'}, iiifManifest)
        .find(c => (c.label[props.language] || c.label.none || Object.values(c.label))?.[0] === pageId))
    }

    const toggleDrawerOpen = () => drawer.open = !drawer.open

    // const drawer = document.querySelector('.drawer')
    const drawerButton = caption.querySelector('.drawer-toggle')
    drawerButton.addEventListener('click', e => toggleDrawerOpen())
  
    document.querySelector('.drawer sl-button.close').addEventListener('click', e => toggleDrawerOpen())

    // recursive helper for finding items in a IIIF manifest
    const findItems = (toMatch, current, found) => {
      found = found || []
      if (current?.items) {
        for (let i = 0; i < current.items.length; i++ ) {
          let item = current.items[i]
          let isMatch = !Object.entries(toMatch).find(([attr, val]) => item[attr] && item[attr] !== val)
          if (isMatch) found.push(item)
          else findItems(toMatch, item, found)
        }
      }
      return found
    }

    // find an item in a IIIF manifest
    const findItem = (toMatch, current, seq) => {
      seq = seq || 1
      const found = findItems(toMatch, current)
      return found.length >= seq ? found[seq-1] : null
    }
    let annotations = []

    const staticImageUrl = (width, crop) => {
      let itemInfo = iiifManifest && findItem({type:'Annotation', motivation:'painting'}, iiifManifest, props.seq).body
      if (!itemInfo) return ''
      if (!imageAspect) imageAspect = itemInfo.width/itemInfo.height
      let url
      let [region, size, rotation, rest] = props.options?.split('/') || []
      let [quality, format] = rest?.split('.') || []
      region = crop, props.region || region || 'full'
      size = width
        ? width === 'max'
          ? 'max'
          : `${width},`
        : props.size
          ? props.size
          : `${main.clientWidth},`
      rotation = parseInt(props.rotation || rotation || 0)
      quality = props.quality || quality || 'default'
      format = props.format || format || 'jpg'
      // console.log(`id=${itemInfo.service[0].id || itemInfo.service[0]['@id']} region=${region} size=${size} rotation=${rotation} quality=${quality} format=${format}`)
      url =`${itemInfo.service[0].id || itemInfo.service[0]['@id']}/${region}/${size}/${rotation}/${quality}.${format}`
      return url
    }

    const showAnnotations = () => {
      annoLayer.style.visibility = 'visible'
    }
    const hideAnnotations = () => annoLayer.style.visibility = 'hidden'
    const enableAnnotations = () => {
      document.querySelector('#showAnnos').style.display = 'none'
      initViewer().then(resp => {
        annotorious.readOnly = false
        showAnnotations()
        annosIcon.style.display = 'none'
        annosEditIcon.style.display = 'inline'
        drawer.open = false
        updateAnnos()
      })
    }
    const toggleAnnotations = () => {
      if (annoLayer) {
        if (annoLayer.style.visibility === 'hidden') showAnnotations(); else hideAnnotations() 
        annosBadge.style.visibility = annotations.length ? annoLayer.style.visibility === 'hidden' ? 'visible' : 'hidden' : 'hidden'
      } else {
        initViewer().then(viewer => {
          if (annoLayer.style.visibility === 'hidden' || props.showannos) showAnnotations(); else hideAnnotations() 
          annosBadge.style.visibility = annotations.length ? annoLayer.style.visibility === 'hidden' ? 'visible' : 'hidden' : 'hidden'
        })
      }
    }
    annosIcon.onclick = () => toggleAnnotations()


    document.querySelector('#showAnnos')?.addEventListener('click', () => { enableAnnotations() })
    document.querySelector('#copyAnnos')?.addEventListener('click', () => { navigator.clipboard.writeText(JSON.stringify(annotations, null, 2)) })

    const mwImage = (mwImg, width) => {
      width = width | 0
      // Converts Wikimedia commons image URL to a thumbnail link
      mwImg = (Array.isArray(mwImg) ? mwImg[0] : mwImg).replace(/Special:FilePath\//, 'File:').split('File:').pop()
      mwImg = decodeURIComponent(mwImg).replace(/ /g,'_')
      const _md5 = md5(mwImg)
      const extension = mwImg.split('.').pop()
      let url = `https://upload.wikimedia.org/wikipedia/commons${width ? '/thumb' : ''}`
      url += `/${_md5.slice(0,1)}/${_md5.slice(0,2)}/${mwImg}`
      if (width > 0) {
        url += `/${width}px-${mwImg}`
        if (extension === 'svg') {
          url += '.png'
        } else if (extension === 'tif' || extension === 'tiff') {
          url += '.jpg'
        }
      }
      return url
    }

    const wdImage = async (qid) => {
      const query = `SELECT ?image WHERE { wd:${qid} wdt:P18 ?image. } LIMIT 1 `;    
      const url = 'https://query.wikidata.org/sparql?query=' + encodeURIComponent(query);
      const headers = { 'Accept': 'application/sparql-results+json' };
      const response = await fetch(url, { headers });
      if (!response.ok) { throw new Error(`SPARQL query failed: ${response.status}`); }
      const json = await response.json();
      const image = json?.results?.bindings?.[0]?.image?.value;
      return image?.replace(/Special:FilePath\//, 'File:').split('File:').pop() || null;
    }

    const initViewer = async () => {
      if (viewer) return viewer
      if (iiifManifest) {
        img.style.display = 'none'
        osd.style.display = 'block'
        osd.style.opacity = 1
        return initOsd(getTileSources())
      } else {
        return loadManifest(props.manifest)
          .then(manifest => {
            img.style.display = 'none'
            osd.style.display = 'block'
            osd.style.opacity = 1
            return initOsd(getTileSources())
          })
      }
    }

    const setCaption = (text) => {
      text = text
        ? text
        : props.caption
          ? props.caption
          : iiifManifest
            ? (iiifManifest?.label?.en || iiifManifest?.label?.none || Object.values(iiifManifest.label)).join(' ')
            : decodeURI(img.src.split('/').pop().replace(/^\d+px-/,'').replace(/\.\S+$/,'').replace(/[-_]+/g,' '))
      if (props.nocaption) {
        caption.style.display = 'none'
      } else {
        captionText.innerHTML = md2Html(text)    
        caption.style.display = 'flex'
        annosBadge.innerHTML = annotations.length
        annosIcon.style.display = annotations.length ? 'inline' : 'none'
        annosBadge.style.display = annotations.length ? 'inline' : 'none'
      }
      img.setAttribute('atl', props.alt || text)
    }

    const loadImage = (url) => {
      img.onload = (e) => {
        imageAspect = img.naturalWidth/img.naturalHeight
        setWindowAspect()
      }
      img.src = url
      img.addEventListener('click', () => {
        // document.querySelector('.overlay').style.display = 'block'
        initViewer().then(_ => document.querySelector('.overlay').style.display = 'none')
      })
    }

    const loadManifest = (manifestUrl) => {
      return fetch(manifestUrl).then(resp => resp.json())
      .then( async manifest => {
        const contexts = Array.isArray(manifest['@context']) ? manifest['@context'] : [manifest['@context']]
        const isV3Manifest = contexts.find(ctx => ctx.indexOf('shared-canvas.org') > 0 || parseFloat(ctx.split('/').slice(-2,-1).pop()) < 3) ? false : true
        return isV3Manifest 
          ? manifest 
          : await fetch(`https://iiif.mdpress.io/prezi2to3/`, { method: 'POST', body: JSON.stringify(manifest) }).then(resp => resp.json())
      })
      .then(manifest => {
        iiifManifest = manifest
        setCaption()
        updateManifestPanel()
        if (!img.src) loadImage(staticImageUrl())
        updateAnnos()
      })
      return iiifManifest
    }

    const getTileSources = () => {
      const canvases = findItems({type:'Canvas'}, iiifManifest)
      const tiledSources = canvases.map(canvas => {
        const page = findItem({type:'AnnotationPage'}, canvas)
        const itemInfo = findItem({type:'Annotation', motivation:'painting'}, page).body
        return itemInfo.service
          ? `${(itemInfo.service[0].id || itemInfo.service[0]['@id'])}/info.json`
          : { url: itemInfo.id, type: 'image', buildPyramid: true }
      })
      return tiledSources
    }

    if (props.src) {
      
      if (props.src.indexOf('http') === 0) {
        props.manifest = `https://iiif.mdpress.io/${props.src}/manifest.json`
        loadImage(props.src)
      } else if (props.src.indexOf('wc:') === 0 || props.src.indexOf('wikimedia.org') > -1 || props.src.indexOf('wikipedia.org') > -1 && props.src.indexOf('/media/File:') > -1) {
        let mwFile = props.src.replace(/^wc:/,'').replace(/Special:FilePath\//, 'File:').split('File:').pop()
        props.manifest = `https://iiif.mdpress.io/wc:${mwFile}/manifest.json`
        loadImage(mwImage(mwFile, main.clientWidth))
      } else if (props.src.indexOf('gh:') === 0) {
        props.manifest = `https://iiif.mdpress.io/${props.src}/manifest.json`
        loadImage(`https://raw.githubusercontent.com/${props.src.slice(3)}`)
      } else if (props.src.indexOf('wd:') === 0 || /^Q[0-9]+$/.test(props.src)) {
        const qid = props.src.replace(/^wd:/, '')
        wdImage(qid).then(mwFile => {
          props.manifest = `https://iiif.mdpress.io/wc:${mwFile}/manifest.json`
          loadImage(mwImage(mwFile, main.clientWidth))
          setCaption()
        })
      } else { // TODO: verify this
        props.manifest = `https://iiif.mdpress.io/gh:${props.ghbase}/${props.src}/manifest.json`
        loadImage(`https://raw.githubusercontent.com/${props.ghbase}${props.src[0] === '/' ? '' : '/'}${props.src}`)
      }
      
      if (props.showannos) toggleAnnotations()
      else loadManifest(props.manifest)
    
    } else if (props.manifest) {
      props.manifest = props.manifest.startsWith('http') ? props.manifest : `https://iiif.mdpress.io/${props.manifest}/manifest.json`
      initViewer()
    }

    setCaption()

    const parseManifest = () =>{

      const valueOf = (langObj, language) => {
        language = language || props.language
        return typeof langObj === 'object' && !Array.isArray(langObj)
          ? langObj[language] || langObj.none || langObj[Object.keys(langObj).sort()[0]]
          : langObj
      }

      const licenseBadge = (rights) => {
        let config = {
          cc: {
            badgeWidth: 88,
            badgeHeight: 31,
            badgeTemplate: 'https://licensebuttons.net/l/${this.rightsCode}${this.rightsCode === "publicdomain" ? "" : "/"+this.version}/${this.badgeWidth}x${this.badgeHeight}.png'
          },
          rs: {
            badgeTemplate: 'https://rightsstatements.org/files/buttons/${this.rightsCode}.white.svg',
            backgroundColor: '318ac7'
          }
        }
        const fillTemplate = (templateString, templateVars) => new Function("return `"+templateString +"`;").call(templateVars)
  
        let badgeHtml = ''
        let [rightsType, _, rightsCode, version] = rights.split('/').slice(2)
        if (rightsType === 'creativecommons.org') {
          rightsCode = rightsCode === 'zero' ? 'publicdomain' : rightsCode
          // rightsCode = rightsCode === 'zero' ? 'publicdomain' : `CC ${rightsCode}`
          badgeHtml = `<img src="${fillTemplate(config.cc.badgeTemplate, {...config.cc, ...{rightsCode, version}})}"/>` 
        } else if (rightsType === 'rightsstatements.org') {
          badgeHtml = `<div style="display:inline-block;height:25px;padding:3px;background-color:#${config.rs.backgroundColor};"><img style="height:100%;" src="${fillTemplate(config.rs.badgeTemplate, {...config.rs, ...{rightsCode}})}"/></div>`
        }
        return badgeHtml
      }  

      let parsed = {}
  
      parsed.id = valueOf(iiifManifest.id)
      parsed.label = valueOf(iiifManifest.label)
  
      if (iiifManifest.summary) parsed.summary = valueOf(iiifManifest.summary)
      if (iiifManifest.rights) {
        let [rightsType, _, rightsCode, version] = iiifManifest.rights.split('/').slice(2)
        if (rightsType === 'creativecommons.org') rightsCode = rightsCode === 'zero' ? 'publicdomain' : `CC ${rightsCode}`
        parsed.rights = {
          code: `${rightsCode} ${version}`.toUpperCase(),
          url: iiifManifest.rights,
          badge: licenseBadge(iiifManifest.rights)
        }
      }
      if (iiifManifest.thumbnail) parsed.thumbnail = iiifManifest.thumbnail[0].id || iiifManifest.thumbnail
      
      if (iiifManifest.metadata) {
        parsed.metadata = iiifManifest.metadata.map((item) => ({label: valueOf(item.label)[0], value: valueOf(item.value)}))
        let sourceUrl = parsed.metadata.find((item) => item.label == 'source_url' || item.label == 'source')
        parsed.sourceUrl = sourceUrl ? sourceUrl.value[0] : null
  
        let depicts = parsed.metadata.find((md) => md.label === 'depicts')
        if (depicts) parsed.depicts = depicts.value
      }
  
      if (iiifManifest.provider) {
        parsed.provider = iiifManifest.provider.map((provider) => {
          let entry = {label: valueOf(provider.label), href:provider.id}
          if (provider.logo) entry.logo = {src:provider.logo[0].id}
          return entry
        })
      }
  
      if (iiifManifest.logo) {
        parsed.logo = iiifManifest.logo.map((item) => {
          let logoObj = { src: typeof item === 'object' ? item.id || item['@id'] : item }
          if (typeof item === 'object') {
            if (item.width) logoObj.width = item.width
            if (item.height) logoObj.height = item.height
          }
          return logoObj
        })
      }
  
      parsed.imageData = findItem({type:'Annotation', motivation:'painting'}, iiifManifest, props.seq)?.body
      parsed.service = parsed.imageData.service && `${(parsed.imageData.service[0].id || parsed.imageData.service[0]['@id'])
        .replace(/\/info\.json$/,'')}/info.json`
        if (iiifManifest.requiredStatement) {
          let rs = iiifManifest.requiredStatement
          // parsed.requiredStatement = {label: valueOf(rs.label)[0], value: valueOf(rs.value)}
        }
  
      if (iiifManifest.homepage) {
        parsed.homepage = {label: iiifManifest.homepage.label ? valueOf(iiifManifest.homepage.label) : iiifManifest.homepage.id, href: iiifManifest.homepage.id}
      }
  
      if (iiifManifest.seeAlso) {
        parsed.seeAlso = iiifManifest.seeAlso.map((seeAlso) => ({label: seeAlso.label ? valueOf(seeAlso.label) : seeAlso.id, href: seeAlso.id}))
      }
      
      return parsed
    }

    const updateManifestPanel = () => {
      let parsed = parseManifest()      
      if (parsed.label) document.querySelector('.manifest .label').innerHTML = parsed.label.join(' ')
      if (parsed.summary) document.querySelector('.manifest .summary').innerHTML = parsed.summary.join(' ')
      if (parsed.requiredStatement) document.querySelector('.manifest .required').innerHTML = `<span><b>Attribution:</b></span> <span>${parsed.requiredStatement.value.join(' ')}</span>`
      if (parsed.rights) document.querySelector('.manifest .rights').innerHTML = `<span><b>Reuse rights:</b></span><a href="${parsed.rights.url}">${parsed.rights.code}</a>` + (parsed.rights.badge || '')
      if (parsed.sourceUrl) document.querySelector('.manifest .source').innerHTML = `<span><b>Source:</b></span> <a href="${parsed.sourceUrl}">${parsed.sourceUrl}</a>`
    
      drawer.querySelectorAll('a').forEach(a => {
        a.addEventListener('click', e => {
          e.stopPropagation()
          e.preventDefault()
          window.parent.postMessage({ type: 'openLink', url: a.href, newtab: true }, '*');
        })
      })

    }

    let annotorious
    let annotationsInitialHash
    let annotationsCurrentHash
    const annotationsChanged = () => {
      annotations = annotorious.getAnnotations()
      let _hash = md5(JSON.stringify(annotations))
      if (!annotationsInitialHash) annotationsInitialHash = _hash
      if (_hash !== annotationsCurrentHash) {
        annotationsCurrentHash = _hash
        setCaption()
        updateAnnos()
      }
    }

    const regionThumbnail = (region, width) => {
      return staticImageUrl(width || 100, region)
    }

    const updateAnnos = () => {
      
      let annosDiv = document.querySelector('#annos')
      
      if (annotorious && document.querySelector('#showAnnos').style.display === 'none') {
        let [owner, repo, branch, ...path] = props.ghbase.split('/')
        path = path.join('/')
        let annosUpdateUrl = annosFound
          ? `https://github.com/${owner}/${repo}/edit/${branch}/${path}/${annosUrl.split('/').pop()}`  
          : `https://github.com/${owner}/${repo}/new/${branch}/?filename=${path}/${annosUrl.split('/').pop()}`
        
        let annosUpdateLink = document.createElement('div')
        annosUpdateLink.innerHTML = `<a href="${annosUpdateUrl}">Save annotations</a>`
        annosUpdateLink.className = 'annosUpdateLink'
        annosUpdateLink.addEventListener('click', (e) => {
          navigator.clipboard.writeText(JSON.stringify(annotorious.getAnnotations(), null, 2))
          window.parent.postMessage({ type: 'openLink', url: annosUpdateUrl, newtab: true }, '*');
        })
        annosDiv.appendChild(annosUpdateLink)
      }

      let annosList = annosDiv.querySelector('ul.annosList')
      if (annosList) annosList.remove()
      annosList = document.createElement('ul')
      annosList.className = 'annosList'
      annotations.forEach(anno => {
        let id = anno.id.split('-')[0].slice(1)
        let text = anno.body.map(b => b.value).join(' ')
        let [x,y,w,h] = anno.target.selector.value.split('pixel:')[1].split(',').map(v => Math.round(parseFloat(v)))
        let region = `${x},${y},${w},${h}`
        let annosListItem = document.createElement('li')
        annosListItem.innerHTML = `<img src="${regionThumbnail(region)}"><div class="wrap"><span>${text}</span><sl-copy-button value="${id}"></sl-copy-button><div>`
        annosList.appendChild(annosListItem)
      })
      annosDiv.appendChild(annosList)
    }

    /**
    * Expand a bounding box to twice its width and height,
    * centering the original box inside the new one.
    *
    * @param {{x:number, y:number, w:number, h:number}} box
    *   The original bounding box.
    * @param {'round'|'floor'|'ceil'} [rounding='round']
    *   How to round the computed coordinates.
    * @returns {{x:number, y:number, w:number, h:number}}
    *   The expanded, centered bounding box.
    */
    function expandBox(box, rounding = 'round') {
      let scale = 1.8;
      // New dimensions
      const newW = box.w * scale;
      const newH = box.h * scale;

      // Center of the original box
      const cx = box.x + box.w / scale;
      const cy = box.y + box.h / scale;

      // Compute top-left of the expanded box so it's centered on (cx,cy)
      let x = cx - newW / scale;
      let y = cy - newH / scale;

      // Apply rounding
      if (rounding === 'floor') {
        x = Math.floor(x);
        y = Math.floor(y);
      } else if (rounding === 'ceil') {
        x = Math.ceil(x);
        y = Math.ceil(y);
      } else {
        x = Math.round(x);
        y = Math.round(y);
      }

      return { x, y, w: newW, h: newH };
    }
    
    /**
    * Place a padded, semiâ€transparent text caption under a box,
    * with fully opaque text.
    *
    * @param {OpenSeadragon.Viewer} viewer
    * @param {{x:number,y:number,w:number,h:number}} box   Imageâ€pixel bbox
    * @param {string} text                                  Caption text
    * @param {object} [opts]
    * @param {number} [opts.fontSize=16]        Font size in px
    * @param {string} [opts.bgColor='#000']     Background hex color (e.g. '#000', '#ff0000')
    * @param {number} [opts.bgOpacity=0.5]      Background alpha (0â€“1)
    * @param {string} [opts.textColor='#fff']   Text color
    * @param {number} [opts.paddingEm=0.5]      Padding around text (in em)
    * @returns {HTMLElement}                     The caption element
    */
    function addTextBelowBox(viewer, box, text, opts = {}) {
      // Default options
      const {
        fontSize   = 16,
        bgColor    = '#000',
        bgOpacity  = 0.5,
        textColor  = '#fff',
        paddingEm  = 0.5,
      } = opts;

      // Helper: turn '#rgb' or '#rrggbb' into 'rgba(r,g,b,alpha)'
      function hexToRgba(hex, alpha) {
        let h = hex.replace('#','');
        if (h.length === 3) {
          h = h.split('').map(c => c + c).join('');
        }
        const int = parseInt(h, 16);
        const r = (int >> 16) & 255;
        const g = (int >> 8) & 255;
        const b = int & 255;
        return `rgba(${r},${g},${b},${alpha})`;
      }

      // 1) Create and style the DIV
      const div = document.createElement('div');
      div.textContent = text;
      Object.assign(div.style, {
        position:        'absolute',
        display:         'inline-block',
        fontSize:        fontSize + 'px',
        backgroundColor: hexToRgba(bgColor, bgOpacity),
        color:           textColor,
        padding:         `${paddingEm}em`,
        boxSizing:       'border-box',
        whiteSpace:      'pre-wrap',
        pointerEvents:   'none',
        opacity:         '1'            // ensure text remains fully opaque
      });

      // 2) Compute the bottom-center of the box in image coords
      const imgX = box.x + box.w/2;
      const imgY = box.y + box.h;

      // 3) Convert to viewport coords
      const vp = viewer.viewport.imageToViewportCoordinates(imgX, imgY);

      // 4) Add as a TOP-centered overlay (auto-width)
      viewer.addOverlay({
        element:   div,
        location:  new OpenSeadragon.Point(vp.x, vp.y),
        placement: OpenSeadragon.Placement.TOP
      });

      return div;
    }

    /**
    * Draws a border around an imageâ€pixel box in an OpenSeadragon viewer.
    *
    * @param {OpenSeadragon.Viewer} viewer
    * @param {{x:number,y:number,w:number,h:number}} box
    *        Box in imageâ€pixel coords (top-left + width/height).
    * @param {object} [opts]
    * @param {string} [opts.color='red']     Border color (any CSS color).
    * @param {number} [opts.lineWidth=2]     Border thickness in px.
    * @returns {HTMLElement}                 The overlay element (for later removal).
    */
    function drawBoxBorder(viewer, box, opts = {}) {
      const {
        color     = 'red',
        lineWidth = 2,
      } = opts;

      // 1) make a DIV sized to 100% Ã— 100% of its overlay rectangle,
      //    with only a border and transparent fill
      const div = document.createElement('div');
      Object.assign(div.style, {
        position:      'absolute',
        width:         '100%',
        height:        '100%',
        boxSizing:     'border-box',
        border:        `${lineWidth}px solid ${color}`,
        background:    'transparent',
        pointerEvents: 'none',
      });

      // 2) map the box corners to viewport coords
      const vpTL = viewer.viewport.imageToViewportCoordinates(box.x,         box.y);
      const vpTR = viewer.viewport.imageToViewportCoordinates(box.x + box.w, box.y);
      const vpBL = viewer.viewport.imageToViewportCoordinates(box.x,         box.y + box.h);

      const widthVP  = vpTR.x - vpTL.x;
      const heightVP = vpBL.y - vpTL.y;

      // 3) build the overlay rectangle
      const rect = new OpenSeadragon.Rect(
        vpTL.x,
        vpTL.y,
        widthVP,
        heightVP
      );

      // 4) add it to the viewer
      viewer.addOverlay({
        element:  div,
        location: rect
      });

      return div;
    }

    const parseRegionString = (region, center) => {
      const s1 = region.split(':')
      let [x,y,w,h] = s1[s1.length-1].split(',').map(v => parseInt(v))
      const size = viewer.world.getItemAt(0)?.getContentSize()
      if (!size) return
      if (s1.length === 2 && (s1[0] === 'pct' || s1[0] === 'percent')) {
        x = Math.round(size.x * x/100),
        y = Math.round(size.y * y/100),
        w = Math.round(size.x * w/100), 
        h = Math.round(size.y * h/100)
      }
      return center
        ? ({x, y, w, h} = expandBox({x, y, w, h}))
        : ({x, y, w, h})
      // return viewer.viewport.imageToViewportRectangle(x,y,w,h)
    }

    let zoomedToRegion = ''
    const zoomto = (where, caption) => {
      let isAnnoId = /^[0-9a-f]{8}$/.test(where)
      let anno = annotations.find(anno => anno.id.slice(1,9) === where)
      let regionStr = anno?.target.selector.value || where
      caption = anno?.body[0].value || caption
      initViewer().then(resp => {
        viewer.clearOverlays();
        if (zoomedToRegion === regionStr) {
          viewer.viewport.goHome()
          zoomedToRegion = ''
        } else {
          zoomedToRegion = regionStr
          let region = parseRegionString(regionStr, false)
          let expandedRegion = parseRegionString(regionStr, true)
          setTimeout(() => {
            let rect = viewer.viewport.imageToViewportRectangle(...Object.values(expandedRegion))
            viewer.viewport.fitBounds(rect, false)
            const borderEl = drawBoxBorder(viewer, region, {
              color:     '#FFFF00',
              lineWidth: 2
            });
            addTextBelowBox(viewer, region, caption, {
              fontSize:  '1em',
              bgColor:   "#fff",
              bgOpacity: 0.8,
              textColor: "#000",
              paddingEm: 0.3
            });
          }, 100)
        }
      })
    }

    const setCoords = () => {
      const tiledImage = viewer.world.getItemAt(0)
      const round = (val) => val % 1 === 0 ? val : parseFloat(val.toFixed(2))
      if (tiledImage) {
        let bounds = viewer.viewport.getBounds()
        const imageBounds = bounds ? tiledImage.viewportToImageRectangle(bounds) : null
        const imageDimensions = tiledImage.getContentSize()
        const boundingBoxPct = {
          x: (imageBounds.x / imageDimensions.x) * 100,
          y: (imageBounds.y / imageDimensions.y) * 100,
          width: (imageBounds.width / imageDimensions.x) * 100,
          height: (imageBounds.height / imageDimensions.y) * 100
        }
        const asCoords = `${Math.ceil(imageBounds.x)},${Math.ceil(imageBounds.y)},${Math.ceil(imageBounds.width)},${Math.ceil(imageBounds.height)}`
        const asPct = `pct:${round(boundingBoxPct.x)},${round(boundingBoxPct.y)},${round(boundingBoxPct.width)},${round(boundingBoxPct.height)}`
        coords.innerHTML = asPct
      }
    }

    const getAnnosUrl = () => {
      let annosUrl
      const itemInfo = findItem({type:'Annotation', motivation:'painting'}, iiifManifest, props.seq)?.body
      const annosFileName = `${decodeURIComponent((itemInfo?.id || img.src).split('/').pop().split('.')[0]).replace(/^\d+px-/,'')}.json`
      if (props.annos) {
        if (props.annos.indexOf('gh:') === 0) {
          let [acct, repo, branch, ...path] = props.annos.slice(3).split('/')
          annosUrl = `https://raw.githubusercontent.com/${acct}/${repo}/${branch}/${path.join('/')}`
        } else {
          annosUrl = props.annos[props.annos.length-1] === '/' ? `${props.annos}${annosFileName}` : props.annos
        }
      } else if (props.ghbase) {
        annosUrl = location.hostname === 'localhost' ? `/${props.ghbase.split('/').slice(3).join('/').replace(/^_/,'')}/${annosFileName}` : `https://raw.githubusercontent.com/${props.ghbase}/${annosFileName}`
      } else if (props.src) {
        if (props.src.indexOf('gh:') === 0) {
          let [acct, repo, branch, ...path] = props.src.slice(3).split('/')
          annosUrl = `https://raw.githubusercontent.com/${acct}/${repo}/${branch}/${path.join('/')}`.replace(/\.\w+$/, '.json')
        } else {
          annosUrl = `${props.src.split('/').slice(0,-1).join('/')}/${annosFileName}`
        }
      }
      return annosUrl
    }

    let annosUrl = getAnnosUrl()
    let annosFound = false

    if (annosUrl) fetch(annosUrl).then(resp => {
      if (resp.ok) {
        resp.json()
          .then(annos => {
            annosFound = true
            annotations = annos
            updateAnnos()
            setCaption()
          })
      }
    })

    const boundingBoxHandler = (e) => {
      const container = document.getElementById("osd");
      const overlay   = document.getElementById("drawing-overlay");
      const ctx       = overlay.getContext("2d");
      let isDrawing = false, startX = 0, startY = 0;
  
      // Array of { rect, el, updateOverlay }
      const boxes = [];
  
      function resizeOverlay() {
        overlay.width  = container.clientWidth;
        overlay.height = container.clientHeight;
      }
      window.addEventListener("resize", resizeOverlay);
      resizeOverlay();
  
      function updateAllBoxes() {
        boxes.forEach(b => b.updateOverlay());
      }
  
      viewer.addHandler("viewport-change", updateAllBoxes);
  
      // === NEW BOX DRAWING ===
      container.addEventListener("pointerdown", e => {
        if (!e.shiftKey) return;
        e.preventDefault(); e.stopImmediatePropagation();
        isDrawing = true;
        viewer.setMouseNavEnabled(false);
        overlay.style.pointerEvents = "auto";
        const r = overlay.getBoundingClientRect();
        startX = e.clientX - r.left;
        startY = e.clientY - r.top;
      }, { capture: true });
  
      document.addEventListener("pointermove", e => {
        if (!isDrawing) return;
        const r = overlay.getBoundingClientRect();
        const x = e.clientX - r.left, y = e.clientY - r.top;
        ctx.clearRect(0,0,overlay.width,overlay.height);
        ctx.strokeStyle = "red"; ctx.lineWidth = 2;
        ctx.strokeRect(startX, startY, x - startX, y - startY);
      });
  
      document.addEventListener("pointerup", e => {
        if (!isDrawing) return;
        isDrawing = false;
        viewer.setMouseNavEnabled(true);
        overlay.style.pointerEvents = "none";
        ctx.clearRect(0,0,overlay.width,overlay.height);
  
        const r = overlay.getBoundingClientRect();
        const endX = e.clientX - r.left, endY = e.clientY - r.top;
        const tl = viewer.viewport.pointFromPixel(new OpenSeadragon.Point(startX, startY));
        const br = viewer.viewport.pointFromPixel(new OpenSeadragon.Point(endX, endY));

        const rect = { x: tl.x, y: tl.y, width: br.x - tl.x, height: br.y - tl.y };

        // Create the HTML overlay
        const boxEl = document.createElement("div");
        boxEl.className = "box";
        container.appendChild(boxEl);
  
        // Resize handlers
        ['nw','ne','sw','se'].forEach(pos => {
          const h = document.createElement("div");
          h.className = `handle ${pos}`;
          boxEl.appendChild(h);
        });
  
        // Copy icon
        const icon = document.createElement("div");
        icon.className = "copy-icon";
        icon.textContent = "ðŸ“‹";
        boxEl.appendChild(icon);
        icon.addEventListener("click", () => {
          console.log(imageAspect)
          // const regionPct = `pct:${(rect.x*100).toFixed(5)},${(rect.y*100*imageAspect).toFixed(5)},${(rect.width*100).toFixed(5)},${(rect.height*100*imageAspect).toFixed(5)}`
          const regionPct = `pct:${(rect.x*100).toFixed(5)},${(rect.y*100).toFixed(5)},${(rect.width*100).toFixed(5)},${(rect.height*100).toFixed(5)}`
          console.log(regionPct)
          navigator.clipboard.writeText(regionPct);
        });

        // Define updateOverlay function
        function updateOverlay() {
          const tlp = viewer.viewport.pixelFromPoint(new OpenSeadragon.Point(rect.x, rect.y), true);
          const brp = viewer.viewport.pixelFromPoint(new OpenSeadragon.Point(rect.x + rect.width, rect.y + rect.height), true);
          const w = brp.x - tlp.x, h = brp.y - tlp.y;
          boxEl.style.left   = tlp.x + "px";
          boxEl.style.top    = tlp.y + "px";
          boxEl.style.width  = w + "px";
          boxEl.style.height = h + "px";
          // position icon
          icon.style.left = (w - 10) + "px";
          icon.style.top  = (h - 10) + "px";
        }
  
        // Initial positioning
        updateOverlay();
  
        // Add to array
        boxes.push({ rect, el: boxEl, updateOverlay });
  
        // === MOVE & RESIZE INTERACTIONS ===
        let action = null, handlePos = null, startPx = 0, startPy = 0, origRect;
  
        boxEl.addEventListener("pointerdown", e => {
          e.stopPropagation(); e.preventDefault();
          if (e.target.classList.contains("handle")) {
            action = "resize";
            handlePos = ['nw','ne','sw','se'].find(p => e.target.classList.contains(p));
          } else {
            action = "move";
          }
          viewer.setMouseNavEnabled(false);
          startPx = e.clientX; startPy = e.clientY;
          origRect = { ...rect };
        });
  
        document.addEventListener("pointermove", e => {
          if (!action) return;
          const dx = e.clientX - startPx, dy = e.clientY - startPy;
          // get original corners in pixel space
          const tlp = viewer.viewport.pixelFromPoint(new OpenSeadragon.Point(origRect.x, origRect.y), true);
          const brp = viewer.viewport.pixelFromPoint(
            new OpenSeadragon.Point(origRect.x + origRect.width, origRect.y + origRect.height), true
          );
          let leftPx = tlp.x, topPx = tlp.y, rightPx = brp.x, bottomPx = brp.y;
  
          if (action === "move") {
            leftPx += dx; rightPx += dx;
            topPx  += dy; bottomPx += dy;
          } else {
            if (handlePos.includes("n")) topPx    += dy;
            if (handlePos.includes("s")) bottomPx += dy;
            if (handlePos.includes("w")) leftPx   += dx;
            if (handlePos.includes("e")) rightPx  += dx;
          }
  
          // convert back to image coords
          const newTL = viewer.viewport.pointFromPixel(new OpenSeadragon.Point(leftPx, topPx));
          const newBR = viewer.viewport.pointFromPixel(new OpenSeadragon.Point(rightPx, bottomPx));
          rect.x      = newTL.x;
          rect.y      = newTL.y;
          rect.width  = newBR.x - newTL.x;
          rect.height = newBR.y - newTL.y;

          updateOverlay();
        });
  
        document.addEventListener("pointerup", () => {
          if (!action) return;
          action = null;
          viewer.setMouseNavEnabled(true);
        });
      });
  
      // Clear on Escape
      document.addEventListener("keydown", e => {
        if (e.key === "Escape") {
          boxes.forEach(b => container.removeChild(b.el));
          boxes.length = 0;
        }
      });
    }

    const initOsd = async (tileSources) => {
      // create the OpenSeadragon viewer
      viewer = OpenSeadragon({
        id: 'osd',
        prefixUrl: 'https://openseadragon.github.io/openseadragon/images/',
        homeFillsViewer: props.cover,
        tileSources,
        crossOriginPolicy: 'Anonymous',
        sequenceMode: tileSources.length > 1,
        initialPage: props.seq - 1,
        showReferenceStrip: tileSources.length > 1,
        zoomPerClick: 1.25,
        maxZoomPixelRatio: 10,
        gestureSettingsMouse: {
          dragToPan: true,
          scrollToZoom: false,
          clickToZoom: true,
          dblClickToZoom: false,
          dblClickDragToZoom: false,
          pinchToZoom: false,
          zoomToRefPoint: false,
          flickEnabled: false,
          flickMinSpeed: 120,
          flickMomentum: 0.25,
          pinchRotate: false
        },
        gestureSettingsTouch: {
          dragToPan: true,
          scrollToZoom: false,
          clickToZoom: false,
          dblClickToZoom: true,
          dblClickDragToZoom: true,
          pinchToZoom: true,
          zoomToRefPoint: false,
          flickEnabled: false,
          flickMinSpeed: 120,
          flickMomentum: 0.25,
          pinchRotate: false
        }
      })
      setPageInfo()

      // display the region coordinates
      let debounce = null

      viewer.addHandler('page', (e) => { 
        props.seq = e.page+1
        setPageInfo()
      })

      viewer.addHandler('viewport-change', () => {
        if (debounce !== null) {
          clearTimeout(debounce)
          debounce = null
        }
        debounce = window.setTimeout(() => setCoords(), 100)
      })

      // Initialize the Annotorious plugin
      annotorious = OpenSeadragon.Annotorious(viewer, { readOnly: true })
      annotorious.on('createAnnotation', () => annotationsChanged())
      annotorious.on('updateAnnotation', () => annotationsChanged())
      annotorious.on('deleteAnnotation', () => annotationsChanged())
      annotorious.on('selectAnnotation', async (anno) => { if (navigator.clipboard) navigator.clipboard.writeText(anno.id.split('-')[0].slice(1)) })
      
      annoLayer = osd.querySelector('.a9s-annotationlayer')
      annoLayer.style.visibility = 'hidden'
      if (props.showannos) showAnnotations()

      let annosUrl = getAnnosUrl()
      if (annosUrl) {
        annotorious.loadAnnotations(annosUrl).then(loaded => { 
          setTimeout(() => annotationsChanged(), 500) 
        })
      }

      viewer.world.addHandler('add-item', (e) => {
        if (props.rotation) e.item.setRotation(parseInt(props.rotation), true)
        if (props.region) {
          let rect = viewer.viewport.imageToViewportRectangle(...Object.values(parseRegionString(props.region)))
          setTimeout(() => viewer.viewport.fitBounds(rect, true), 0)
        }
        setCoords() 
      })

      viewer.addHandler("open", () => boundingBoxHandler())

      return new Promise((resolve, reject) => {
        
        // Listen for the 'open' event which fires when the initial image is loaded
        viewer.addOnceHandler('open', () => resolve(viewer))
        
        // Listen for errors
        viewer.addOnceHandler('open-failed', (event) => reject(new Error('Failed to load image: ' + event.message)))

      })

    }

  </script>
</body>
</html>